use crate::core::{DepotError, DepotResult};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// The new lockfile name
pub const LOCKFILE_NAME: &str = "depot.lock";

/// The old lockfile name (for migration)
const OLD_LOCKFILE_NAME: &str = "package.lock";

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Lockfile {
    #[serde(default = "default_lockfile_version")]
    pub version: u32,
    pub generated_at: DateTime<Utc>,
    #[serde(default)]
    pub packages: HashMap<String, LockedPackage>,
}

fn default_lockfile_version() -> u32 {
    1
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedPackage {
    pub version: String,
    pub source: String,
    #[serde(default)]
    pub rockspec_url: Option<String>,
    #[serde(default)]
    pub source_url: Option<String>,
    pub checksum: String,
    #[serde(default)]
    pub size: Option<u64>,
    #[serde(default)]
    pub dependencies: HashMap<String, String>,
    #[serde(default)]
    pub build: Option<LockedBuild>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LockedBuild {
    #[serde(rename = "type")]
    pub build_type: String,
    pub target: String,
    pub built_at: DateTime<Utc>,
    #[serde(default)]
    pub installed_files: Vec<String>,
}

impl Lockfile {
    /// Load lockfile from a directory (with automatic migration from package.lock to depot.lock)
    pub fn load(dir: &Path) -> DepotResult<Option<Self>> {
        let new_path = dir.join(LOCKFILE_NAME);
        let old_path = dir.join(OLD_LOCKFILE_NAME);

        // Check if new lockfile exists
        if new_path.exists() {
            let content = fs::read_to_string(&new_path)?;
            let lockfile: Lockfile = serde_yaml::from_str(&content).map_err(|e| {
                DepotError::Package(format!("Failed to parse {}: {}", LOCKFILE_NAME, e))
            })?;
            return Ok(Some(lockfile));
        }

        // Check if old lockfile exists and migrate
        if old_path.exists() {
            let content = fs::read_to_string(&old_path)?;
            let lockfile: Lockfile = serde_yaml::from_str(&content).map_err(|e| {
                DepotError::Package(format!("Failed to parse {}: {}", OLD_LOCKFILE_NAME, e))
            })?;

            // Auto-migrate: save to new location
            lockfile.save(dir)?;

            // Remove old lockfile after successful migration
            fs::remove_file(&old_path)?;

            eprintln!("✓ Migrated {} → {}", OLD_LOCKFILE_NAME, LOCKFILE_NAME);

            return Ok(Some(lockfile));
        }

        Ok(None)
    }

    /// Save lockfile to a directory
    pub fn save(&self, dir: &Path) -> DepotResult<()> {
        let path = dir.join(LOCKFILE_NAME);

        // Add header comment
        let mut content = String::from("# DO NOT EDIT - Generated by Depot\n");
        let yaml = serde_yaml::to_string(self).map_err(|e| {
            DepotError::Package(format!("Failed to serialize {}: {}", LOCKFILE_NAME, e))
        })?;
        content.push_str(&yaml);

        fs::write(&path, content)?;
        Ok(())
    }

    /// Create a new empty lockfile
    pub fn new() -> Self {
        Self {
            version: 1,
            generated_at: Utc::now(),
            packages: HashMap::new(),
        }
    }

    /// Add a package to the lockfile
    pub fn add_package(&mut self, name: String, package: LockedPackage) {
        self.packages.insert(name, package);
    }

    /// Get a package from the lockfile
    pub fn get_package(&self, name: &str) -> Option<&LockedPackage> {
        self.packages.get(name)
    }

    /// Check if a package is in the lockfile
    pub fn has_package(&self, name: &str) -> bool {
        self.packages.contains_key(name)
    }
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_lockfile_new() {
        let lockfile = Lockfile::new();
        assert_eq!(lockfile.version, 1);
        assert!(lockfile.packages.is_empty());
    }

    #[test]
    fn test_lockfile_add_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: Some("https://example.com/test-1.0.0.rockspec".to_string()),
            source_url: Some("https://example.com/test-1.0.0.tar.gz".to_string()),
            checksum: "abc123".to_string(),
            size: Some(1024),
            dependencies: std::collections::HashMap::new(),
            build: None,
        };

        lockfile.add_package("test-package".to_string(), package);
        assert!(lockfile.has_package("test-package"));
    }

    #[test]
    fn test_lockfile_get_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };

        lockfile.add_package("test-package".to_string(), package.clone());
        let retrieved = lockfile.get_package("test-package");
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap().version, "1.0.0");
    }

    #[test]
    fn test_lockfile_has_package() {
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };

        assert!(!lockfile.has_package("test-package"));
        lockfile.add_package("test-package".to_string(), package);
        assert!(lockfile.has_package("test-package"));
    }

    #[test]
    fn test_lockfile_save_and_load() {
        let temp = TempDir::new().unwrap();
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: Some("https://example.com/test-1.0.0.rockspec".to_string()),
            source_url: Some("https://example.com/test-1.0.0.tar.gz".to_string()),
            checksum: "abc123".to_string(),
            size: Some(1024),
            dependencies: std::collections::HashMap::new(),
            build: None,
        };

        lockfile.add_package("test-package".to_string(), package);
        lockfile.save(temp.path()).unwrap();

        let loaded = Lockfile::load(temp.path()).unwrap().unwrap();
        assert_eq!(loaded.version, 1);
        assert!(loaded.has_package("test-package"));
        let loaded_pkg = loaded.get_package("test-package").unwrap();
        assert_eq!(loaded_pkg.version, "1.0.0");
        assert_eq!(loaded_pkg.checksum, "abc123");
    }

    #[test]
    fn test_lockfile_load_nonexistent() {
        let temp = TempDir::new().unwrap();
        let result = Lockfile::load(temp.path()).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_locked_package_with_dependencies() {
        let mut dependencies = std::collections::HashMap::new();
        dependencies.insert("dep1".to_string(), "1.0.0".to_string());
        dependencies.insert("dep2".to_string(), "2.0.0".to_string());

        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies,
            build: None,
        };

        assert_eq!(package.dependencies.len(), 2);
        assert_eq!(package.dependencies.get("dep1"), Some(&"1.0.0".to_string()));
    }

    #[test]
    fn test_locked_package_with_build() {
        let build = LockedBuild {
            build_type: "rust".to_string(),
            target: "x86_64-unknown-linux-gnu".to_string(),
            built_at: chrono::Utc::now(),
            installed_files: vec!["lib.so".to_string()],
        };

        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: Some(build),
        };

        assert!(package.build.is_some());
        assert_eq!(package.build.as_ref().unwrap().build_type, "rust");
    }

    #[test]
    fn test_lockfile_load_invalid_yaml() {
        let temp = TempDir::new().unwrap();
        let lockfile_path = temp.path().join(LOCKFILE_NAME);
        fs::write(&lockfile_path, "invalid: yaml: [").unwrap();

        let result = Lockfile::load(temp.path());
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("parse"));
    }

    #[test]
    fn test_lockfile_save_io_error() {
        let temp = TempDir::new().unwrap();
        let lockfile = Lockfile::new();

        // Try to save to a non-existent parent directory
        let invalid_path = temp.path().join("nonexistent").join("subdir");
        let result = lockfile.save(&invalid_path);
        // May succeed if parent is created, or fail on write
        let _ = result;
    }

    #[test]
    fn test_lockfile_default() {
        let lockfile = Lockfile::default();
        assert_eq!(lockfile.version, 1);
        assert!(lockfile.packages.is_empty());
    }

    #[test]
    fn test_lockfile_get_package_nonexistent() {
        let lockfile = Lockfile::new();
        assert!(lockfile.get_package("nonexistent").is_none());
    }

    #[test]
    fn test_lockfile_has_package_false() {
        let lockfile = Lockfile::new();
        assert!(!lockfile.has_package("nonexistent"));
    }

    #[test]
    fn test_lockfile_migration_from_old_name() {
        let temp = TempDir::new().unwrap();

        // Create an old-style lockfile
        let mut lockfile = Lockfile::new();
        let package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "abc123".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        lockfile.add_package("test-package".to_string(), package);

        // Save using old filename manually
        let old_path = temp.path().join(OLD_LOCKFILE_NAME);
        let mut content = String::from("# DO NOT EDIT - Generated by Depot\n");
        let yaml = serde_yaml::to_string(&lockfile).unwrap();
        content.push_str(&yaml);
        fs::write(&old_path, content).unwrap();

        // Verify old file exists
        assert!(old_path.exists());
        assert!(!temp.path().join(LOCKFILE_NAME).exists());

        // Load should trigger migration
        let loaded = Lockfile::load(temp.path()).unwrap().unwrap();

        // Verify migration occurred
        assert!(!old_path.exists(), "Old lockfile should be deleted");
        assert!(
            temp.path().join(LOCKFILE_NAME).exists(),
            "New lockfile should exist"
        );
        assert!(loaded.has_package("test-package"));
    }

    #[test]
    fn test_lockfile_prefers_new_name() {
        let temp = TempDir::new().unwrap();

        // Create both old and new lockfiles with different content
        let mut old_lockfile = Lockfile::new();
        let old_package = LockedPackage {
            version: "1.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "old".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        old_lockfile.add_package("old-package".to_string(), old_package);

        let mut new_lockfile = Lockfile::new();
        let new_package = LockedPackage {
            version: "2.0.0".to_string(),
            source: "luarocks".to_string(),
            rockspec_url: None,
            source_url: None,
            checksum: "new".to_string(),
            size: None,
            dependencies: std::collections::HashMap::new(),
            build: None,
        };
        new_lockfile.add_package("new-package".to_string(), new_package);

        // Save both manually
        let old_path = temp.path().join(OLD_LOCKFILE_NAME);
        let new_path = temp.path().join(LOCKFILE_NAME);

        fs::write(&old_path, serde_yaml::to_string(&old_lockfile).unwrap()).unwrap();
        fs::write(&new_path, serde_yaml::to_string(&new_lockfile).unwrap()).unwrap();

        // Load should prefer new lockfile
        let loaded = Lockfile::load(temp.path()).unwrap().unwrap();

        // Verify it loaded the new lockfile (not the old one)
        assert!(loaded.has_package("new-package"));
        assert!(!loaded.has_package("old-package"));

        // Old lockfile should still exist (no migration attempted)
        assert!(old_path.exists());
    }
}
